<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Hoops</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            background-image: radial-gradient(circle, #333, #1a1a1a);
        }
        .game-container {
            position: relative;
            width: 1000px;
            height: 600px;
            border: 4px solid #333;
            background-color: #000;
            box-shadow: 0 0 30px rgba(255, 165, 0, 0.5);
        }
        canvas { display: block; }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }
        .hidden { display: none; }
        .menu-box {
            background-color: #2c2c2c;
            border: 4px solid #fd9500;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 0 20px rgba(253, 149, 0, 0.7);
            max-width: 600px;
        }
        .menu-box h1 {
            font-size: 2.5em;
            margin: 0 0 20px 0;
            color: #fd9500;
            text-shadow: 3px 3px 0 #000;
        }
        .menu-box h2 { font-size: 1.5em; margin: 20px 0; }
        .menu-box p { font-size: 0.8em; line-height: 1.5; max-width: 500px; text-align: left;}
        .btn {
            font-family: 'Press Start 2P', cursive;
            background-color: #fd9500;
            color: #fff;
            border: 2px solid #fff;
            padding: 15px 25px;
            font-size: 1em;
            cursor: pointer;
            margin: 10px;
            text-shadow: 2px 2px 0 #000;
            transition: all 0.2s ease;
        }
        .btn:hover { background-color: #ffaf4d; transform: translateY(-2px); }
        
        .setup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .setup-row h2 {
            font-size: 1.2em;
            margin-right: 20px;
        }
        .setup-btn-group {
            display: flex;
        }
        .setup-btn.active {
            background-color: #e67e22;
            box-shadow: inset 0 0 10px #000;
        }

        #start-game-btn {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 6;
        }

        #scoreboard {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, rgba(30,30,30,0.95) 0%, rgba(50,50,50,0.85) 100%);
            border-bottom: 4px solid #fd9500;
            padding: 5px 30px;
            font-size: 1.5em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 300px;
            text-align: center;
            z-index: 5;
            color: #fff;
            border-radius: 0 0 20px 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .team-score { display: flex; align-items: center; font-weight: bold; }
        .p1-color { color: #e74c3c; text-shadow: 1px 1px 5px #000; }
        .p2-color { color: #3498db; text-shadow: 1px 1px 5px #000; }
        #timer { font-size: 1.2em; min-width: 60px; color: #f1c40f;}

        #game-message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5em;
            text-shadow: 3px 3px 0 #000;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        .show-message { opacity: 1; }
        #game-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 11;
        }
        .control-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            color: white;
            font-size: 2em;
        }
        .control-btn svg {
            width: 32px;
            height: 32px;
            fill: white;
            filter: drop-shadow(2px 2px 2px #000);
        }
        
        /* Vertical Shot Meter */
        #shot-meter {
            position: absolute;
            width: 15px; 
            height: 120px;
            background-color: rgba(0,0,0,0.5);
            border: 2px solid white;
            z-index: 6;
            display: none; 
            flex-direction: column-reverse;
            border-radius: 10px;
            overflow: hidden;
            transition: box-shadow 0.1s ease;
            pointer-events: none;
        }
        #shot-meter-bar {
            width: 100%;
            background-color: #fff;
            transition: height 0.05s linear, background-color 0.2s ease;
        }
        .flash-green #shot-meter-bar {
            background-color: #00FF00 !important; /* Solid green as requested */
            height: 100% !important; /* Fill the bar on green */
        }
        #shot-meter-green-zone {
            position: absolute;
            bottom: 85%; /* Perfect release zone at the top */
            width: 100%;
            height: 15%;
            background-color: rgba(46, 204, 113, 0.7);
        }
        .flash-green {
            box-shadow: 0 0 25px 8px #2ecc71, inset 0 0 10px #fff;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="shot-meter">
            <div id="shot-meter-green-zone"></div>
            <div id="shot-meter-bar"></div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="game-controls">
            <button id="help-btn" class="control-btn">?</button>
            <button id="home-btn" class="control-btn hidden">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8h5z"/></svg>
            </button>
            <button id="pause-btn" class="control-btn hidden">❚❚</button>
        </div>

        <div id="scoreboard" class="hidden">
             <div class="team-score">
                <span id="p1Score" class="p1-color">0</span>
            </div>
            <div id="timer-container"><span id="timer">60</span></div>
            <div class="team-score">
                <span id="p2Score" class="p2-color">0</span>
            </div>
        </div>
        
        <button id="start-game-btn" class="btn hidden">Start Game</button>
        <div id="game-message"></div>

        <!-- Menus -->
        <div id="main-menu" class="ui-overlay">
            <div class="menu-box">
                <h1>Arcade Hoops</h1>
                <div>
                    <button id="play-btn" class="btn">Play</button>
                </div>
            </div>
        </div>
        <div id="game-setup-menu" class="ui-overlay hidden">
            <div class="menu-box">
                <h1>Game Setup</h1>
                <div class="setup-row">
                    <h2>Players</h2>
                    <div class="setup-btn-group">
                        <button class="btn setup-btn active" data-setup="players" data-value="1">1P VS CPU</button>
                        <button class="btn setup-btn" data-setup="players" data-value="2">2 Players</button>
                    </div>
                </div>
                <div class="setup-row" id="difficulty-row">
                    <h2>Difficulty</h2>
                    <div class="setup-btn-group">
                        <button class="btn setup-btn" data-setup="difficulty" data-value="easy">Easy</button>
                        <button class="btn setup-btn active" data-setup="difficulty" data-value="medium">Medium</button>
                        <button class="btn setup-btn" data-setup="difficulty" data-value="hard">Hard</button>
                    </div>
                </div>
                <div class="setup-row">
                    <h2>Game Mode</h2>
                     <div class="setup-btn-group">
                        <button class="btn setup-btn active" data-setup="mode" data-value="score">First to 21</button>
                        <button class="btn setup-btn" data-setup="mode" data-value="time">60 Seconds</button>
                    </div>
                </div>
                <button id="start-setup-btn" class="btn">Start Game</button>
                <button class="btn back-btn" data-target="main-menu">Back</button>
            </div>
        </div>
        <div id="game-over-menu" class="ui-overlay hidden">
            <div class="menu-box">
                <h1 id="winner-text">Game Over!</h1>
                <h2 id="final-score-text"></h2>
                <div>
                    <button id="play-again-same-settings-btn" class="btn">Play Again</button>
                    <button id="main-menu-btn" class="btn">Menu</button>
                    <button id="start-ot-btn" class="btn hidden">Start OT</button>
                </div>
            </div>
        </div>
        <div id="help-menu" class="ui-overlay hidden">
            <div class="menu-box">
                <h1>Controls</h1>
                <h2>Player 1 (Red)</h2>
                <p>Move: WASD Keys<br>Jump/Shoot/Block: F<br>Steal: G<br>Crossover: Double-tap G</p>
                <h2>Player 2 (Blue)</h2>
                <p>Move: Arrow Keys<br>Jump/Shoot/Block: K<br>Steal: L<br>Crossover: Double-tap L</p>
                <div id="audio-controls" style="margin-top: 20px; text-align: left;">
                    <p style="margin-bottom: 10px;">Music Select:</p>
                    <div style="display: flex; justify-content: center; align-items: center; flex-wrap: wrap;">
                        <button class="btn music-btn" data-music="0">Music 1</button>
                        <button class="btn music-btn" data-music="1">Music 2</button>
                        <button class="btn music-btn" data-music="2">Music 3</button>
                        <button id="mute-btn" class="btn" style="padding: 10px; font-size: 1em; width: 60px; height: 60px; vertical-align: middle;">
                             <svg id="mute-icon" viewBox="0 0 24 24" style="width: 100%; height: 100%; fill: white;">
                                <path id="speaker-path" d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path>
                                <path id="slash-path" d="M 2 2 L 22 22" stroke="white" stroke-width="3" style="display: none;"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                <button id="close-help-btn" class="btn">Close</button>
            </div>
        </div>
        <div id="pause-menu" class="ui-overlay hidden">
            <div class="menu-box">
                <h1>Paused</h1>
                <button id="resume-btn" class="btn">Resume</button>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script>
    window.addEventListener('DOMContentLoaded', () => {

        // --- DOM Elements ---
        const gameContainer = document.querySelector('.game-container');
        const canvas = document.getElementById('gameCanvas');
        const allMenus = document.querySelectorAll('.ui-overlay');
        const mainMenu = document.getElementById('main-menu');
        const gameSetupMenu = document.getElementById('game-setup-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const helpMenu = document.getElementById('help-menu');
        const pauseMenu = document.getElementById('pause-menu');
        const scoreboard = document.getElementById('scoreboard');
        const gameMessage = document.getElementById('game-message');
        const pauseBtn = document.getElementById('pause-btn');
        const helpBtn = document.getElementById('help-btn');
        const homeBtn = document.getElementById('home-btn');
        const shotMeter = document.getElementById('shot-meter');
        const shotMeterBar = document.getElementById('shot-meter-bar');
        const startGameBtn = document.getElementById('start-game-btn');
        const startOtBtn = document.getElementById('start-ot-btn');

        // --- Game State & Config ---
        let gameState = 'menu';
        let gameMode = '', numPlayers = 1, cpuDifficulty = 'medium';
        let p1Score = 0, p2Score = 0, timer = 60, timerInterval, overtimeLevel = 0;
        let tipOffStarted = false;
        let shotClockExpired = false;
        let isMuted = false;
        const keys = {};
        const keyPressHistory = {};
        let announcerVoice = null;
        let waveState = { active: false, startTime: 0, duration: 6000 };

        // --- 3D Scene Constants ---
        let scene, camera, renderer, players, ball;
        const hoops = [];
        const crowdMeshes = [];
        let spotlight;
        const court = { width: 80, depth: 40 };
        const GRAVITY = -50;
        const PLAYER_SPEED = 20; // Base speed for human players
        const JUMP_FORCE = 22;
        const CPU_DIFFICULTY = {
            easy:   { speed: 0.75, accuracy: 0.5, stealChance: 0.005, blockChance: 0.01, crossoverChance: 0.005 },
            medium: { speed: 1.0,  accuracy: 0.7, stealChance: 0.01,  blockChance: 0.02, crossoverChance: 0.01 },
            hard:   { speed: 1.6,  accuracy: 1.0, stealChance: 0.06,  blockChance: 0.03, crossoverChance: 0.02 }
        };

        // --- Audio Engine ---
        let musics = [];
        let currentMusicIndex = -1;
        const cheerFilter = new Tone.AutoFilter("2n").toDestination().start();
        const sounds = {
            bounce: new Tone.MembraneSynth({volume: -5}).toDestination(),
            shoot: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
            swoosh: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 }, volume: -3 }).toDestination(),
            green: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 } }).toDestination(),
            whistle: new Tone.Synth({ oscillator: { type: 'sine' }, frequency: 1200, envelope: { attack: 0.1, decay: 0.2, sustain: 0.1, release: 0.5 } }).toDestination(),
            buzzer: new Tone.Synth({ oscillator: { type: 'sawtooth' }, frequency: 150, envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.2 } }).toDestination(),
            countdown: new Tone.Synth({ oscillator: { type: 'sine' }, frequency: 880, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
            backboard: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 }, volume: -5 }).toDestination(),
            cheer: new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.2, decay: 2.5, sustain: 0.1, release: 1.0 }, volume: 10 }).connect(cheerFilter),
        };
        
        function initAllMusic() {
            // Music 1 (Original)
            const synth1 = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "pulse", width: 0.2 }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 } }).toDestination();
            const bass1 = new Tone.MonoSynth({ oscillator: { type: "fmsquare", modulationType: "sawtooth", modulationIndex: 0.5 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
            const melodyPart1 = new Tone.Sequence((time, note) => { synth1.triggerAttackRelease(note, "16n", time); }, ["C4", ["E4", "G4"], "C5", null, "G4", null, "E4", null], "8n");
            const bassPart1 = new Tone.Sequence((time, note) => { bass1.triggerAttackRelease(note, "8n", time); }, ["C2", "G2", "A2", "F2"], "2n");
            musics.push({ parts: [melodyPart1, bassPart1], bpm: 120 });

            // Music 2 (Uptempo)
            const synth2 = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, detune: 0, oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 1 }, modulation: { type: "square" }, modulationEnvelope: { attack: 0.5, decay: 0.01 } }).toDestination();
            const melodyPart2 = new Tone.Sequence((time, note) => { synth2.triggerAttackRelease(note, "8n", time); }, ["F4", "G4", "A#4", "G4", "F4", null, "F4", "D#4"], "8n");
            const bassPart2 = new Tone.Sequence((time, note) => { bass1.triggerAttackRelease(note, "4n", time); }, ["F2", "A#1", "D#2", "C2"], "1n");
            musics.push({ parts: [melodyPart2, bassPart2], bpm: 140 });

            // Music 3 (Chill)
            const synth3 = new Tone.AMSynth({ harmonicity: 1.5, detune: 0, oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 1 } }).toDestination();
            const melodyPart3 = new Tone.Sequence((time, note) => { synth3.triggerAttackRelease(note, "4n", time); }, [["C4", "E4"], "G4", ["A4", "G4"], "E4"], "4n");
            const bassPart3 = new Tone.Sequence((time, note) => { bass1.triggerAttackRelease(note, "2n", time); }, ["C2", "G1", "A1", "E1"], "1m");
            musics.push({ parts: [melodyPart3, bassPart3], bpm: 100 });
        }
        
        function switchMusic(index) {
            if (index === currentMusicIndex || !musics[index]) return;

            if (currentMusicIndex !== -1) {
                musics[currentMusicIndex].parts.forEach(part => part.stop(0));
            }
            
            currentMusicIndex = index;
            const newMusic = musics[currentMusicIndex];
            Tone.Transport.bpm.value = newMusic.bpm;
            newMusic.parts.forEach(part => part.start(0));
            
            if (Tone.Transport.state !== 'started') {
                Tone.Transport.start();
            }
        }
        
        // --- Initialize 3D World ---
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2b1f);

            camera = new THREE.PerspectiveCamera(60, 1000 / 600, 0.1, 1000);
            camera.position.set(0, 30, 65);
            camera.lookAt(0, 5, 0);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(1000, 600);
            renderer.shadowMap.enabled = true;
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(0, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -60;
            directionalLight.shadow.camera.right = 60;
            directionalLight.shadow.camera.top = 60;
            directionalLight.shadow.camera.bottom = -60;
            scene.add(directionalLight);

            spotlight = new THREE.SpotLight(0xffffff, 0.5, 100, Math.PI / 8, 0.5);
            spotlight.castShadow = true;
            scene.add(spotlight);
            scene.add(spotlight.target);
        }

        // --- Model Creation ---
        function createCourt() {
            const courtGroup = new THREE.Group();
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x6B4423 }); // Darker brown
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(court.width, court.depth), floorMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            courtGroup.add(ground);
            
            // --- UPDATED: Add court logo ---
            const textureLoader = new THREE.TextureLoader();
            
            // NOTE: We need the full file ID for the uploaded image.
            const logoTexture = textureLoader.load('uploaded:Screenshot_2025-10-02_12.57.56_PM-removebg-preview.png-06a8ca23-70c6-4fdd-96ce-f3fe085fa339');
            
            // The logo has a dark background and text, so we'll apply a white color filter
            // using the MeshBasicMaterial's color property and its alpha channel from the texture.
            const logoGeometry = new THREE.PlaneGeometry(15, 15); // Adjusted size to fit well
            const logoMaterial = new THREE.MeshBasicMaterial({ 
                map: logoTexture, 
                transparent: true,
                depthWrite: false, // Helps with transparency rendering
                color: 0xffffff, // Set the color of the logo to WHITE
            });
            const logoMesh = new THREE.Mesh(logoGeometry, logoMaterial);
            logoMesh.position.y = 0.05; // Slightly above the floor to prevent z-fighting
            logoMesh.rotation.x = -Math.PI / 2; // Lay it flat on the court
            courtGroup.add(logoMesh);
            
            // Court Lines
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            
            // Half-court line (raised slightly to be on top of the logo)
            const halfCourtPoints = [new THREE.Vector3(0, 0.06, -court.depth/2), new THREE.Vector3(0, 0.06, court.depth/2)];
            const halfCourtGeo = new THREE.BufferGeometry().setFromPoints(halfCourtPoints);
            const halfCourtLine = new THREE.Line(halfCourtGeo, lineMaterial);
            courtGroup.add(halfCourtLine);
            
            scene.add(courtGroup);
        }

        function createHoop(x, z, rotationY) {
            const hoopGroup = new THREE.Group();
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const mainPole = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 10, 16), poleMat);
            mainPole.position.y = 5; mainPole.castShadow = true;
            
            const backboardMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.1 });
            const backboardMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 7, 10), backboardMat);
            backboardMesh.castShadow = true;
            backboardMesh.position.set(2, 12, 0);
            
            const rim = new THREE.Mesh(new THREE.TorusGeometry(2.5, 0.3, 8, 32), new THREE.MeshStandardMaterial({ color: 0xfd9500 }));
            rim.position.set(4.5, 10, 0);
            rim.rotation.x = Math.PI / 2;
            
            const netGeo = new THREE.CylinderGeometry(2.5, 1.5, 3, 12, 1, true);
            const netMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.8 });
            const net = new THREE.Mesh(netGeo, netMat);
            net.position.set(4.5, 8.5, 0);

            hoopGroup.add(mainPole, backboardMesh, rim, net);
            hoopGroup.position.set(x, 0, z); hoopGroup.rotation.y = rotationY;
            scene.add(hoopGroup);

            const scoreZone = new THREE.Vector3();
            rim.getWorldPosition(scoreZone);
            const backboardBox = new THREE.Box3().setFromObject(backboardMesh);
            hoops.push({ obj: hoopGroup, rim: rim, scoreZone: scoreZone, backboardBox: backboardBox });
        }
        
        function createRandomSpectatorMesh() {
            const shapes = [
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.SphereGeometry(0.7, 8, 8),
                new THREE.CylinderGeometry(0.5, 0.5, 1.2, 8),
                new THREE.ConeGeometry(0.6, 1.5, 3) // Triangular Prism approx
            ];
            const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(Math.random(), Math.random(), Math.random()) });
            const geo = shapes[Math.floor(Math.random() * shapes.length)];
            return new THREE.Mesh(geo, mat);
        }
        
        function createCrowdSection(position, rotation, numSeats = 40) {
             const crowdGroup = new THREE.Group();
            const numRows = 4;
            for (let row = 0; row < numRows; row++) {
                for (let i = 0; i < numSeats; i++) {
                    const spectator = createRandomSpectatorMesh();
                    const scale = Math.random() * 0.4 + 0.8;
                    spectator.scale.set(scale, scale, scale);
                    spectator.position.set((i * 2) - numSeats, (row * 2) + 1, -(row * 3));
                    spectator.userData = { cheerUntil: 0, baseY: spectator.position.y };
                    crowdGroup.add(spectator);
                    crowdMeshes.push(spectator);
                }
            }
            crowdGroup.position.copy(position); crowdGroup.rotation.y = rotation; scene.add(crowdGroup);
        }

        function createAllCrowds() {
            createCrowdSection(new THREE.Vector3(0, 0, -court.depth / 2 - 8), 0);
            createCrowdSection(new THREE.Vector3(0, 0, court.depth / 2 + 8), Math.PI);
            createCrowdSection(new THREE.Vector3(-court.width / 2 - 8, 0, 0), -Math.PI / 2, 20);
            createCrowdSection(new THREE.Vector3(court.width / 2 + 8, 0, 0), Math.PI / 2, 20);
        }
        
        function createStickman(color) {
            const stickman = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({ color: color });
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), material);
            head.position.y = 5.5;
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 4, 8), material);
            body.position.y = 2;
            
            const armGeo = new THREE.CylinderGeometry(0.25, 0.25, 2.5, 8);
            const rightArm = new THREE.Mesh(armGeo, material);
            rightArm.position.set(-0.75, 3, 0);
            rightArm.rotation.z = Math.PI / 6;
            const leftArm = new THREE.Mesh(armGeo, material);
            leftArm.position.set(0.75, 3, 0);
            leftArm.rotation.z = -Math.PI / 6;

            stickman.add(head, body, rightArm, leftArm);
            stickman.traverse(child => { child.castShadow = true; });
            stickman.userData = { bbox: new THREE.Box3(), arms: { right: rightArm, left: leftArm } };
            scene.add(stickman);
            return stickman;
        }

        // --- Core Game Logic ---
        function initGame(isOvertime = false) {
            gameState = 'playing';
            tipOffStarted = false;
            shotClockExpired = false;
            if (!isOvertime) {
                p1Score = 0; 
                p2Score = 0;
            }
            document.getElementById('timer-container').style.display = (gameMode === 'time' || overtimeLevel > 0) ? 'flex' : 'none';
            timer = overtimeLevel > 0 ? 15 : (gameMode === 'time' ? 60 : 0);
            
            startGameBtn.classList.remove('hidden');
            
            if (players) players.forEach(p => scene.remove(p.obj));
            if (ball) scene.remove(ball.obj);
            
            players = []; ball = {};

            const p1 = { id: 1, obj: createStickman(0xe74c3c), hasBall: false, isJumping: false, isShooting: false, shotPower: 0, shotPowerIncreasing: true, isCPU: false, velocity: new THREE.Vector3(), onGround: true, stealCooldown: 0, direction: new THREE.Vector2(1, 0) };
            p1.obj.position.set(-10, 0, 0);
            players.push(p1);

            const p2 = { id: 2, obj: createStickman(0x3498db), hasBall: false, isJumping: false, isShooting: false, shotPower: 0, shotPowerIncreasing: true, isCPU: numPlayers === 1, velocity: new THREE.Vector3(), onGround: true, stealCooldown: 0, cpuState: 'IDLE', cpuTimer: 0, direction: new THREE.Vector2(-1, 0) };
            p2.obj.position.set(10, 0, 0);
            players.push(p2);

            ball.obj = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshStandardMaterial({ color: 0xf39c12 }));
            scene.add(ball.obj); 
            ball.obj.castShadow = true;
            ball.velocity = new THREE.Vector3(0, 0, 0); 
            ball.scored = false;
            ball.isGuaranteed = false;
            ball.passedThroughRim = null;
            ball.reboundableTime = 0;
            ball.lastBounceTime = 0;
            ball.obj.userData.bbox = new THREE.Box3();
            ball.crossoverTween = null;
            ball.dribble = { height: 3.5, goingDown: true, speed: 40 };
            ball.obj.position.set(0, 15, 0); // Tip-off height

            updateScoreboard();
            
            if (timerInterval) clearInterval(timerInterval);
            updateButtonVisibility();
        }
        
        function startTimer() {
            if (tipOffStarted) return;
            tipOffStarted = true;
            ball.velocity.set(0, -10, 0); // Start the tip-off
            sounds.whistle.triggerAttackRelease("G5", "8n", Tone.now());
            if(gameMode === 'time' || overtimeLevel > 0) {
                timerInterval = setInterval(() => {
                    if (gameState === 'playing') {
                        timer--;
                        if (timer <= 5 && timer > 0) {
                            sounds.countdown.triggerAttackRelease("A5", "16n", Tone.now());
                        }
                        updateScoreboard();
                        if (timer <= 0) {
                             clearInterval(timerInterval);
                             sounds.buzzer.triggerAttackRelease("G2", "1n", Tone.now());
                             shotClockExpired = true;
                        }
                    }
                }, 1000);
            }
        }
        
        function jumpAndShoot(p) {
            if (!p || !p.isShooting) return;
            shootBall(p);
            p.isShooting = false;
        }

        function update(delta, time) {
            if (shotClockExpired) {
                const ballHolder = players.find(p => p.hasBall);
                if (ballHolder || (ball.obj.position.y < 1.1 && Math.abs(ball.velocity.y) < 2)) {
                    let winnerText;
                    if (p1Score > p2Score) winnerText = "Player 1 Wins!";
                    else if (p2Score > p1Score) winnerText = numPlayers === 1 ? "CPU Wins!" : "Player 2 Wins!";
                    else winnerText = "Time's Up!"; 
                    endGame(winnerText);
                    shotClockExpired = false; 
                }
            }

            players.forEach(p => {
                p.obj.userData.bbox.setFromObject(p.obj);
                if (tipOffStarted) {
                    p.isCPU ? updateCPU(p, delta) : updatePlayer(p, delta, time);
                }
            });
            
            const shootingPlayer = players.find(p => p.isShooting && !p.isCPU);
            if (shootingPlayer) {
                updateShotMeter(shootingPlayer);
            } else {
                shotMeter.style.display = 'none';
            }
            
            ball.obj.userData.bbox.setFromObject(ball.obj);
            const ballHolder = players.find(p => p.hasBall);
            if (ballHolder) {
                const holderPos = ballHolder.obj.position;
                let handOffset = new THREE.Vector3(ballHolder.direction.x * 1.5, 3.5, 0);
                
                if (ballHolder.onGround) {
                     if (ball.dribble.goingDown) {
                        ball.dribble.height -= ball.dribble.speed * delta;
                        if (ball.dribble.height < 1.0) {
                            ball.dribble.height = 1.0;
                            ball.dribble.goingDown = false;
                            const now = Tone.now(); if (now - ball.lastBounceTime > 0.1) { sounds.bounce.triggerAttackRelease("C2", "8n", now, 0.5); ball.lastBounceTime = now; }
                        }
                    } else {
                        ball.dribble.height += ball.dribble.speed * delta;
                        if (ball.dribble.height > 3.5) {
                            ball.dribble.height = 3.5;
                            ball.dribble.goingDown = true;
                        }
                    }
                    handOffset.y = ball.dribble.height;
                    
                    const dribbleProgress = (ball.dribble.height - 1.0) / (3.5 - 1.0);
                    const armAngleOffset = dribbleProgress * (Math.PI / 8);
                    ballHolder.obj.userData.arms.right.rotation.z = Math.PI / 6 + armAngleOffset;
                    ballHolder.obj.userData.arms.left.rotation.z = -Math.PI / 6 - armAngleOffset;

                } else { handOffset.y = 3.5; }

                if (ball.crossoverTween) {
                    const elapsed = Date.now() - ball.crossoverTween.startTime;
                    if (elapsed < ball.crossoverTween.duration) {
                         const progress = elapsed / ball.crossoverTween.duration;
                         const crossZ = Math.sin(progress * Math.PI) * ball.crossoverTween.strength;
                         handOffset.z = crossZ;
                    } else { ball.crossoverTween = null; }
                }
                ball.obj.position.copy(holderPos).add(handOffset);
                ball.velocity.set(0, 0, 0);
                spotlight.position.set(ball.obj.position.x, 20, ball.obj.position.z);
                spotlight.target.position.copy(ball.obj.position);

            } else { if (tipOffStarted) { updateBall(delta); } }
            
            animateCrowd(time);
            renderer.render(scene, camera);
        }
        
        let targetVel = new THREE.Vector3(); 
        function updatePlayer(p, delta, time) {
            // Both P1 and P2 use the same moveSpeed (PLAYER_SPEED) in 2P mode for equal performance.
            targetVel.set(0,0,0);
            const moveSpeed = PLAYER_SPEED; 
            const playerKeys = p.id === 1 ?
                { left: 'KeyA', right: 'KeyD', up: 'KeyW', down: 'KeyS', action: 'KeyF', steal: 'KeyG' } :
                { left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp', down: 'ArrowDown', action: 'KeyK', steal: 'KeyL' };

            if (keys[playerKeys.left]) targetVel.x -= moveSpeed;
            if (keys[playerKeys.right]) targetVel.x += moveSpeed;
            if (keys[playerKeys.up]) targetVel.z -= moveSpeed;
            if (keys[playerKeys.down]) targetVel.z += moveSpeed;
            
            if (targetVel.length() > 0) {
                 p.direction.set(targetVel.x, targetVel.z).normalize();
                 p.obj.rotation.y = Math.atan2(p.direction.x, p.direction.y);
            }

            p.velocity.x += (targetVel.x - p.velocity.x) * 0.1;
            p.velocity.z += (targetVel.z - p.velocity.z) * 0.1;
            
            if (keys[playerKeys.action]) {
                if (p.hasBall) {
                    if (p.onGround) {
                        p.velocity.y = JUMP_FORCE; p.onGround = false; p.isJumping = true; p.isShooting = true; p.shotPower = 0; p.shotPowerIncreasing = true;
                    } else if (p.isShooting) {
                        p.shotPower += (p.shotPowerIncreasing ? 1 : -1) * 2 * delta;
                        if (p.shotPower >= 1) { p.shotPower = 1; p.shotPowerIncreasing = false; }
                        if (p.shotPower <= 0 && !p.shotPowerIncreasing) { p.shotPower = 0; p.shotPowerIncreasing = true; }
                    }
                } else if (p.onGround) {
                    p.velocity.y = JUMP_FORCE; p.onGround = false; p.isJumping = true;
                }
            }

            p.stealCooldown -= delta;
            if (keys[playerKeys.steal] && !p.hasBall && p.stealCooldown <= 0) {
                const opponent = players.find(op => op.hasBall);
                if (opponent && p.obj.position.distanceTo(opponent.obj.position) < 4 && opponent.onGround) {
                    showMessage("STEAL!", "#f1c40f"); resetBall(p);
                }
                p.stealCooldown = 1;
            }

            p.velocity.y += GRAVITY * delta;
            p.obj.position.add(p.velocity.clone().multiplyScalar(delta));
            if (p.obj.position.y < 0) {
                p.obj.position.y = 0; p.velocity.y = 0;
                if(p.isJumping) { p.isJumping = false; p.onGround = true; }
            }
            
            p.obj.position.x = Math.max(-court.width/2, Math.min(court.width/2, p.obj.position.x));
            p.obj.position.z = Math.max(-court.depth/2, Math.min(court.depth/2, p.obj.position.z));
        }

        function updateCPU(cpu, delta) {
            const humanPlayer = players[0];
            const difficulty = CPU_DIFFICULTY[cpuDifficulty];
            const targetHoop = hoops[0];
            const ownHoop = hoops[1];
            const ballHolder = players.find(p => p.hasBall);

            cpu.cpuTimer -= delta;
            if (!ballHolder) { cpu.cpuState = 'GET_BALL'; } 
            else if (cpu.hasBall) { cpu.cpuState = 'ATTACKING'; } 
            else { cpu.cpuState = 'DEFENDING'; }
            
            let targetVel = new THREE.Vector3();

            if (cpu.cpuState === 'GET_BALL') {
                const directionToBall = ball.obj.position.clone().sub(cpu.obj.position).normalize();
                targetVel.x = directionToBall.x * PLAYER_SPEED * difficulty.speed;
                targetVel.z = directionToBall.z * PLAYER_SPEED * difficulty.speed;
                if (ball.obj.position.y > 5 && cpu.onGround) {
                    cpu.velocity.y = JUMP_FORCE; cpu.onGround = false; cpu.isJumping = true;
                }
            }
            else if (cpu.cpuState === 'ATTACKING') {
                if (Math.random() < difficulty.crossoverChance && !ball.crossoverTween) {
                    ball.crossoverTween = { startTime: Date.now(), duration: 200, strength: 2.5 };
                }

                const distanceToHoop = cpu.obj.position.distanceTo(targetHoop.obj.position);
                const distanceToPlayer = cpu.obj.position.distanceTo(humanPlayer.obj.position);
                
                let moveTarget;
                const isClearPath = Math.abs(cpu.obj.position.z - humanPlayer.obj.position.z) > 5 || cpu.obj.position.x > humanPlayer.obj.position.x;
                
                if (distanceToHoop < 12 && isClearPath) { moveTarget = targetHoop.obj.position.clone(); } 
                else if (distanceToHoop < 28) { moveTarget = cpu.obj.position.clone(); moveTarget.x = targetHoop.obj.position.x + 15; }
                else { moveTarget = targetHoop.obj.position.clone(); moveTarget.x += 25; moveTarget.z += (Math.random() - 0.5) * 20; }

                if (distanceToPlayer < 8) {
                    const awayVector = cpu.obj.position.clone().sub(humanPlayer.obj.position).normalize();
                    moveTarget.add(awayVector.multiplyScalar(5));
                }
                
                const directionToTarget = moveTarget.clone().sub(cpu.obj.position).normalize();
                targetVel.x = directionToTarget.x * PLAYER_SPEED * difficulty.speed;
                targetVel.z = directionToTarget.z * PLAYER_SPEED * difficulty.speed;
                
                const canShoot = cpu.cpuTimer <= 0 && distanceToHoop < 35 && distanceToPlayer > 5;
                if (canShoot) {
                    cpu.isShooting = true;
                    const idealShotPower = 0.92;
                    const accuracyError = (1 - difficulty.accuracy) * 0.15;
                    const finalShotPower = idealShotPower + (Math.random() - 0.5) * accuracyError;
                    cpu.shotPower = finalShotPower;
                    setTimeout(() => { if (cpu.isShooting) jumpAndShoot(cpu); }, 200);
                    cpu.cpuTimer = 2.5 + Math.random(); 
                }
            } 
            else if (cpu.cpuState === 'DEFENDING') {
                let defensePosition = (cpuDifficulty === 'hard') ? humanPlayer.obj.position.clone() : new THREE.Vector3().lerpVectors(humanPlayer.obj.position, ownHoop.obj.position, 0.3);
                const directionToDefense = defensePosition.clone().sub(cpu.obj.position).normalize();
                targetVel.x = directionToDefense.x * PLAYER_SPEED * difficulty.speed;
                targetVel.z = directionToDefense.z * PLAYER_SPEED * difficulty.speed;
                
                const distanceToPlayer = cpu.obj.position.distanceTo(humanPlayer.obj.position);
                if (distanceToPlayer < 4 && Math.random() < difficulty.stealChance && cpu.onGround && humanPlayer.onGround) {
                     showMessage("STOLEN!", "#3498db"); resetBall(cpu);
                }
                if (distanceToPlayer < 6 && humanPlayer.isShooting && Math.random() < difficulty.blockChance && cpu.onGround) {
                    cpu.velocity.y = JUMP_FORCE * 0.9; cpu.onGround = false; cpu.isJumping = true;
                }
            }

            cpu.velocity.x += (targetVel.x - cpu.velocity.x) * 0.1;
            cpu.velocity.z += (targetVel.z - cpu.velocity.z) * 0.1;
            cpu.velocity.y += GRAVITY * delta;
            cpu.obj.position.add(cpu.velocity.clone().multiplyScalar(delta));
            if (cpu.obj.position.y < 0) {
                cpu.obj.position.y = 0; cpu.velocity.y = 0;
                if(cpu.isJumping) { cpu.isJumping = false; cpu.onGround = true; }
            }
        }
        
        function shootBall(p) {
            p.hasBall = false;
            ball.isGuaranteed = false;
            ball.reboundableTime = Date.now() + 750;

            const isThree = (p.id === 1 && p.obj.position.x < 0) || (p.id === 2 && p.obj.position.x > 0);
            ball.shotValue = isThree ? 3 : 2;
            
            const targetHoop = p.id === 1 ? hoops[1] : hoops[0];
            const distance = p.obj.position.distanceTo(targetHoop.scoreZone);
            const isLayup = distance < 12;

            if (isLayup) { ball.isGuaranteed = Math.random() < 0.9; }

            const accuracy = p.isCPU ? p.shotPower : (1 - Math.abs(p.shotPower - 0.925));
            const isGreen = !isLayup && accuracy > 0.98;

            if (isGreen) {
                playAnnouncerVoice("Green light!");
                showMessage("GREEN LIGHT!", "#2ecc71");
                shotMeter.classList.add('flash-green');
                sounds.green.triggerAttackRelease("G5", "8n", Tone.now());
                createGreenCircleEffect(p.obj.position);
                setTimeout(() => shotMeter.classList.remove('flash-green'), 500);
                ball.isGuaranteed = true;
            }
            
            let targetPos = targetHoop.scoreZone.clone();
            
            if (!ball.isGuaranteed) {
                const missFactor = isLayup ? 1.5 : 8;
                const missAmount = missFactor * (1 - accuracy);
                targetPos.x += (Math.random() - 0.5) * missAmount;
                targetPos.y += (Math.random() - 0.5) * missAmount * 0.5;
                targetPos.z += (Math.random() - 0.5) * missAmount;
            }

            const startPos = p.obj.position.clone().add(new THREE.Vector3(0, 5, 0));
            ball.obj.position.copy(startPos);
            const displacement = targetPos.clone().sub(startPos);
            
            let power, angle;
            if (isLayup) { power = 25; angle = Math.PI / 3; } 
            else { power = 28 + distance * 0.45; angle = Math.PI / 4 + (distance / court.width) * (Math.PI / 8); }
            
            const horizVel = power * Math.cos(angle);
            const vertVel = power * Math.sin(angle);
            const horizDir = new THREE.Vector3(displacement.x, 0, displacement.z).normalize();
            ball.velocity.set(horizDir.x * horizVel, vertVel, horizDir.z * horizVel);

            p.shotPower = 0; p.shotPowerIncreasing = true;
        }
        
        function createGreenCircleEffect(position) {
            const ringGeo = new THREE.RingGeometry(0.1, 4, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x00FF00, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(position);
            ring.position.y = 0.1;
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            let startTime = Date.now();
            const duration = 500;
            
            function animateRing() {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    ring.scale.set(easeOut, easeOut, easeOut);
                    ring.material.opacity = 1 - easeOut;
                    requestAnimationFrame(animateRing);
                } else { scene.remove(ring); }
            }
            animateRing();
        }

        function updateBall(delta) {
            const targetHoop = ball.velocity.x > 0 ? hoops[1] : hoops[0];
            
            if (ball.isGuaranteed) {
                if (ball.obj.position.distanceTo(targetHoop.scoreZone) < 50 && ball.velocity.y < 10) {
                    const directionToHoop = targetHoop.scoreZone.clone().sub(ball.obj.position).normalize();
                    ball.velocity.add(directionToHoop.multiplyScalar(8.0));
                }
                if (ball.obj.position.distanceTo(targetHoop.scoreZone) < 10) {
                    ball.obj.position.lerp(targetHoop.scoreZone, 0.3);
                }
                if (!ball.scored && ball.obj.position.distanceTo(targetHoop.scoreZone) < 2.5) {
                    handleScore(targetHoop === hoops[0] ? 2 : 1);
                }
            }

            ball.velocity.y += GRAVITY * delta;
            ball.obj.position.add(ball.velocity.clone().multiplyScalar(delta));

            players.forEach(p => {
                if(!p.onGround && ball.velocity.y > 0 && p.obj.position.distanceTo(ball.obj.position) < 4) {
                    if (p.isCPU && cpuDifficulty === 'hard' && Math.random() < 0.3) return; 
                    showMessage("BLOCKED!", "#e74c3c");
                    ball.velocity.multiplyScalar(-0.5); ball.velocity.y *= 0.5; ball.isGuaranteed = false;
                }
            });

            if (ball.obj.position.y < 1.1 && Math.abs(ball.velocity.y) > 2) {
                const now = Tone.now(); if (now - ball.lastBounceTime > 0.1) { sounds.bounce.triggerAttackRelease("C2", "8n", now, Math.min(Math.abs(ball.velocity.y) / 20, 1)); ball.lastBounceTime = now; }
                ball.obj.position.y = 1; ball.velocity.y *= -0.7; ball.passedThroughRim = null;
            }
            if (Math.abs(ball.obj.position.x) > court.width / 2) { ball.velocity.x *= -0.8; }
            if (Math.abs(ball.obj.position.z) > court.depth / 2) { ball.velocity.z *= -0.8; }
            
            if (ball.obj.position.y < 5 && !ball.scored && !players.some(p => p.hasBall) && Date.now() > ball.reboundableTime) {
                let closestPlayer = null, minDist = 4;
                players.forEach(p => {
                    const dist = p.obj.position.distanceTo(ball.obj.position);
                    if (dist < minDist) { minDist = dist; closestPlayer = p; }
                });
                if (closestPlayer) resetBall(closestPlayer);
            }

            hoops.forEach((hoop, index) => {
                if (ball.obj.userData.bbox.intersectsBox(hoop.backboardBox)) {
                    const now = Tone.now(); if (now - ball.lastBounceTime > 0.1) { sounds.backboard.triggerAttackRelease("C3", "8n", now); ball.lastBounceTime = now; }
                    const normal = new THREE.Vector3(hoop.obj.rotation.y !== 0 ? 1 : -1, 0, 0); 
                    ball.velocity.reflect(normal).multiplyScalar(0.9);
                    ball.obj.position.add(normal.multiplyScalar(0.2));
                    ball.velocity.y += (Math.random() - 0.2) * 2; ball.isGuaranteed = false;
                }
                if (!ball.scored && !ball.passedThroughRim && ball.velocity.y < 0 && Math.abs(ball.obj.position.y - hoop.scoreZone.y) < 0.5) {
                    if (ball.obj.position.distanceTo(hoop.scoreZone) < 2.5) { ball.passedThroughRim = hoop; }
                }
                if (ball.passedThroughRim === hoop && ball.obj.position.y < hoop.scoreZone.y - 2) {
                    handleScore(index === 0 ? 2 : 1);
                    ball.passedThroughRim = null;
                }
            });
        }
        
        function handleScore(scoringPlayerId) {
            if (ball.scored) return;
            ball.scored = true;
            ball.isGuaranteed = false; 
            ball.obj.position.y = hoops[0].scoreZone.y - 1; 
            ball.velocity.set(0, -20, 0); 
            
            sounds.swoosh.triggerAttackRelease("8n", Tone.now());
            triggerCrowdCheer(); 

            let otherPlayer;
            const points = ball.shotValue || 2;
            
            if (scoringPlayerId === 1) {
                p1Score += points; otherPlayer = players.find(p => p.id === 2);
            } else {
                p2Score += points; otherPlayer = players.find(p => p.id === 1);
            }

            if (points === 3) {
                playAnnouncerVoice("Gimme three!");
                showMessage("THREE POINTER!", "#f1c40f");
            }

            updateScoreboard();

            if (gameMode === 'score' && (p1Score >= 21 || p2Score >= 21)) {
                let winner = p1Score >= 21 ? "Player 1" : (numPlayers === 1 ? "CPU" : "Player 2");
                endGame(`${winner} Wins!`);
            } else {
                 setTimeout(() => resetPositionsAfterScore(otherPlayer), 2000);
            }
        }
        
        function resetBall(playerWithBall) {
            playerWithBall.hasBall = true;
            ball.scored = false;
            players.forEach(p => { if(p !== playerWithBall) p.hasBall = false; });
        }
        
        function resetPositionsAfterScore(playerToReceiveBall) {
            ball.velocity.set(0, 0, 0);
            
            const inboundX = playerToReceiveBall.id === 1 ? -court.width / 4 : court.width / 4;
            playerToReceiveBall.obj.position.set(inboundX, 0, 0);
            playerToReceiveBall.velocity.set(0,0,0);
            
            const defender = players.find(p => p !== playerToReceiveBall);
            defender.obj.position.set(-inboundX, 0, 0);
            defender.velocity.set(0,0,0);

            setTimeout(() => resetBall(playerToReceiveBall), 100);
        }
        
        function endGame(winnerText) {
            gameState = 'gameOver';
            if (timerInterval) clearInterval(timerInterval);

            if ((gameMode === 'time' || overtimeLevel > 0) && p1Score === p2Score) {
                document.getElementById('winner-text').textContent = "OVERTIME!";
                document.getElementById('final-score-text').textContent = `Tied ${p1Score} - ${p2Score}`;
                startOtBtn.textContent = `Start OT`;
                startOtBtn.classList.remove('hidden');
                document.getElementById('main-menu-btn').classList.add('hidden');
                document.getElementById('play-again-same-settings-btn').classList.add('hidden');
                playAnnouncerVoice("Overtime!");
            } else {
                document.getElementById('winner-text').textContent = winnerText;
                document.getElementById('final-score-text').textContent = `${p1Score} - ${p2Score}`;
                startOtBtn.classList.add('hidden');
                document.getElementById('main-menu-btn').classList.remove('hidden');
                document.getElementById('play-again-same-settings-btn').classList.remove('hidden');
            }
            switchMenu(gameOverMenu);
            updateButtonVisibility();
        }

        function startOvertime() {
            overtimeLevel++;
            gameState = 'playing';
            switchMenu(null);
            initGame(true); // Pass true to indicate this is OT and scores should not reset
        }

        function playAnnouncerVoice(text) {
            if ('speechSynthesis' in window && announcerVoice) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.voice = announcerVoice;
                utterance.lang = 'en-US';
                utterance.rate = 1.1;
                utterance.pitch = 0.6;
                speechSynthesis.speak(utterance);
            }
        }

        function animateCrowd(time) {
            const timeInSeconds = time * 0.001;
            if (waveState.active) {
                const waveProgress = (time - waveState.startTime) / waveState.duration;
                if (waveProgress > 1.2) { waveState.active = false; }
                crowdMeshes.forEach(spectator => {
                    const worldPos = new THREE.Vector3();
                    spectator.getWorldPosition(worldPos);
                    const wavePos = (worldPos.x / court.width) * 4; 
                    const waveOffset = Math.sin((wavePos - waveProgress * 8) * Math.PI) * 3;
                    spectator.position.y = spectator.userData.baseY + (waveOffset > 0 ? waveOffset : 0);
                });
            } else {
                 crowdMeshes.forEach((spectator, index) => {
                    if (spectator.userData.cheerUntil > time) {
                        const cheerDuration = 1000;
                        const timeSinceCheerStart = spectator.userData.cheerUntil - time;
                        const progress = 1 - (timeSinceCheerStart / cheerDuration);
                        spectator.position.y = spectator.userData.baseY + Math.sin(progress * Math.PI) * 3;
                    } else {
                        spectator.position.y = spectator.userData.baseY + Math.sin(timeInSeconds * 2 + index * 0.5) * 0.2;
                    }
                });
            }
        }
        
        function triggerCrowdCheer() {
            if (!isMuted) sounds.cheer.triggerAttackRelease("1.5s", Tone.now());
            const cheerDuration = 1000;
            const now = Date.now();
            crowdMeshes.forEach(spectator => { spectator.userData.cheerUntil = now + cheerDuration; });
            waveState.active = true;
            waveState.startTime = lastTime;
        }

        function updateShotMeter(p) {
            const screenPos = toScreenPosition(p.obj, camera);
            shotMeter.style.display = 'flex';
            shotMeter.style.left = `${screenPos.x - 40}px`;
            shotMeter.style.top = `${screenPos.y - 120}px`;
            shotMeterBar.style.height = `${p.shotPower * 100}%`;
            if (p.shotPower > 0.85 && p.shotPower < 1.0) {
                 shotMeterBar.style.backgroundColor = '#00FF00';
            } else {
                 shotMeterBar.style.backgroundColor = '#fff';
            }
        }
        
        function toScreenPosition(obj, camera) {
            const vector = new THREE.Vector3();
            obj.getWorldPosition(vector); 
            vector.project(camera);
            return {
                x: (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth,
                y: (vector.y * -0.5 + 0.5) * renderer.domElement.clientHeight
            };
        }
        
        function updateScoreboard() {
            document.getElementById('p1Score').textContent = p1Score;
            document.getElementById('p2Score').textContent = p2Score;
            if(gameMode === 'time' || overtimeLevel > 0) {
                document.getElementById('timer').textContent = timer.toString().padStart(2, '0');
            }
        }
        
        function showMessage(msg, color) {
            gameMessage.textContent = msg; gameMessage.style.color = color;
            gameMessage.classList.add('show-message');
            setTimeout(() => gameMessage.classList.remove('show-message'), 1500);
        }
        
        function switchMenu(targetMenu) {
            allMenus.forEach(menu => menu.classList.add('hidden'));
            if(targetMenu) targetMenu.classList.remove('hidden');
        }

        function updateButtonVisibility() {
            const isPlaying = gameState === 'playing';
            const isPaused = gameState === 'paused';
            const isMenu = gameState === 'menu' || gameState === 'gameOver';
            pauseBtn.classList.toggle('hidden', !isPlaying && !isPaused);
            homeBtn.classList.toggle('hidden', isPlaying);
            helpBtn.classList.toggle('hidden', !(isMenu || isPaused));
            scoreboard.classList.toggle('hidden', isMenu);
            if (tipOffStarted) {
                startGameBtn.classList.add('hidden');
            }
        }

        function setupUIListeners() {
            document.getElementById('play-btn').addEventListener('click', () => { 
                if (Tone.context.state !== 'running') {
                    Tone.start().then(() => {
                        console.log("Audio Context is running");
                        initAllMusic();
                        switchMusic(0);
                    });
                }
                switchMenu(gameSetupMenu); 
            });

            document.querySelectorAll('.back-btn').forEach(btn => btn.addEventListener('click', e => switchMenu(document.getElementById(e.target.dataset.target))));
            
            document.querySelectorAll('.setup-btn').forEach(btn => {
                btn.addEventListener('click', e => {
                    const target = e.currentTarget;
                    const setupType = target.dataset.setup;
                    document.querySelectorAll(`.setup-btn[data-setup="${setupType}"]`).forEach(b => b.classList.remove('active'));
                    target.classList.add('active');
                    if (setupType === 'players') {
                        const is1P = target.dataset.value === '1';
                        document.getElementById('difficulty-row').style.display = is1P ? 'flex' : 'none';
                    }
                });
            });

            document.getElementById('start-setup-btn').addEventListener('click', () => {
                numPlayers = parseInt(document.querySelector('.setup-btn[data-setup="players"].active').dataset.value, 10);
                if (numPlayers === 1) {
                    cpuDifficulty = document.querySelector('.setup-btn[data-setup="difficulty"].active').dataset.value;
                }
                gameMode = document.querySelector('.setup-btn[data-setup="mode"].active').dataset.value;
                overtimeLevel = 0;
                switchMenu(null);
                initGame();
            });

            startGameBtn.addEventListener('click', () => {
                startTimer();
                startGameBtn.classList.add('hidden');
            });

            startOtBtn.addEventListener('click', () => { startOvertime(); });
            
            document.getElementById('play-again-same-settings-btn').addEventListener('click', () => {
                overtimeLevel = 0;
                switchMenu(null);
                initGame();
            });

            document.getElementById('main-menu-btn').addEventListener('click', () => { 
                gameState = 'menu';
                overtimeLevel = 0;
                startOtBtn.classList.add('hidden');
                switchMenu(mainMenu); 
                updateButtonVisibility(); 
            });
            helpBtn.addEventListener('click', () => { if (gameState === 'menu' || gameState === 'gameOver' || gameState === 'paused') switchMenu(helpMenu); });
            document.getElementById('close-help-btn').addEventListener('click', () => {
                 if (gameState === 'paused') switchMenu(pauseMenu);
                 else switchMenu(gameState === 'gameOver' ? gameOverMenu : mainMenu);
            });
            
            document.querySelectorAll('.music-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const musicId = parseInt(e.target.dataset.music, 10);
                    switchMusic(musicId);
                });
            });

            document.getElementById('mute-btn').addEventListener('click', () => {
                isMuted = !isMuted;
                Tone.Master.mute = isMuted;
                document.getElementById('slash-path').style.display = isMuted ? 'block' : 'none';
            });
            
            homeBtn.addEventListener('click', () => {
                clearInterval(timerInterval);
                gameState = 'menu';
                overtimeLevel = 0;
                startOtBtn.classList.add('hidden');
                switchMenu(mainMenu);
                updateButtonVisibility();
                shotMeter.style.display = 'none';
            });

            const togglePause = () => {
                if (gameState === 'playing' || gameState === 'paused') {
                    gameState = gameState === 'playing' ? 'paused' : 'playing';
                    pauseBtn.textContent = gameState === 'paused' ? '▶' : '❚❚';
                    if (gameState === 'paused') { if (currentMusicIndex !== -1) Tone.Transport.pause(); } 
                    else { if (currentMusicIndex !== -1) Tone.Transport.start(); }
                    switchMenu(gameState === 'paused' ? pauseMenu : null);
                    updateButtonVisibility();
                }
            };
            pauseBtn.addEventListener('click', togglePause);
            document.getElementById('resume-btn').addEventListener('click', togglePause);
        }
        
        function setupKeyListeners() {
            const crossoverThreshold = 250;
            window.addEventListener('keydown', (e) => {
                 if(!keys[e.code]) {
                    const now = Date.now();
                    const p1StealKey = 'KeyG', p2StealKey = 'KeyL';
                    let player = null;
                    if(e.code === p1StealKey) player = players[0];
                    if(e.code === p2StealKey) player = players[1];
                    if (player && player.hasBall && now - (keyPressHistory[e.code] || 0) < crossoverThreshold) {
                        if (!ball.crossoverTween) { ball.crossoverTween = { startTime: now, duration: 200, strength: 2 }; }
                    }
                    keyPressHistory[e.code] = now;
                 }
                 keys[e.code] = true;
                 if (e.code === 'KeyP') { document.getElementById('pause-btn').click(); }
            });
            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                const p1Action = 'KeyF', p2Action = 'KeyK';
                if(e.code === p1Action) jumpAndShoot(players[0]);
                if(e.code === p2Action) jumpAndShoot(players[1]);
            });
        }

        // --- Initial Setup ---
        initThree();
        createCourt();
        createAllCrowds();
        createHoop(-court.width / 2 + 5.25, 0, 0);
        createHoop(court.width / 2 - 5.25, 0, Math.PI);
        setupUIListeners();
        setupKeyListeners();
        updateButtonVisibility();
        
        let lastTime = 0;
        function animate(time) {
            time = time || 0;
            const delta = Math.min((time - lastTime) * 0.001, 0.05);
            lastTime = time;
            requestAnimationFrame(animate);
            if (gameState === 'playing' || gameState === 'paused') {
                 if (gameState === 'playing') { update(delta, time); }
            } else {
                animateCrowd(time);
                renderer.render(scene, camera);
            }
        }
        
        function setupAnnouncer() {
             if ('speechSynthesis' in window) {
                const setVoice = () => {
                    const voices = speechSynthesis.getVoices();
                    announcerVoice = voices.find(v => v.name.includes('Google US English') && v.gender === 'male') 
                                || voices.find(v => v.lang === 'en-US' && v.name.toLowerCase().includes('male'))
                                || voices.find(v => v.lang === 'en-US');
                };
                setVoice();
                if (speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = setVoice;
                }
            }
        }
        setupAnnouncer();
        animate();
        
    });
    </script>
</body>
</html>

